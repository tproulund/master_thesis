\section{Conveyor belt dynamics}
The purpose of this section is to derive a model for the housing moving on the conveyor belt and set up a prediction model.
\subsection{Housing model}
One of the requirements of this report, is that all information about the conveyor belt is unknown. It is therefore necessary to make assumption about the dynamics of the conveyor belt, which is that the acceleration is constant, but unknown, for a  finite time. This enables the possibility to derive a simple model for position and velocity:
\begin{align}
\ddot x &= a \\
\dot x &= \dot x(t_0)+a\g(t-t_0)\\
x & = x(t_0)+\dot x(t_0)(t-t_0)\frac{a}{2}(t-t_0)^2
\end{align}
Since the vision system operates in the discrete time, this models needs to be transformed to the discrete domain:
\begin{align}
\dot x(z) &= \dot x(z^{-1})+a\\
x(z) & = x(z^{-1})+\dot x(z^{-1})+\frac{a}{2}
\end{align} 
Since the robot needs to place the lid on the housing, it is better for the model to predict the future position of the housing, since it else would always be lacking behind. This is done by multiplying with $z$ in the model, also the model is written in the final state space form.
\begin{equation}\label{eq_ss}
\underbrace{\mat{x(z^2)\\\dot x(z^2)}}_{x_{k+1}}=\overbrace{\mat{1 & 1\\ 0 & 1}}^F\underbrace{\mat{x(z)\\\dot x(z)}}_{x_k}+\mat{1\\\frac{1}{2}}a
\end{equation}
The desired outputs of the model are both position and velocity so the output is defined as
\begin{equation}
y = H\g x
\end{equation}
Where $H$ is a matrix determining which state to use as output. The last term in \eqref{eq_ss} is not used further since no information about the acceleration is known. For this model to work, it is necessary to have it converge on the measurement from the vision system, to achieve this, it is decided to use the Kalman filter. The reason for this is the Kalman filter is both and estimater and filter, which means it will converge towards the system dynamics using the outputs from the vision system, but it can also filter the noise generated by the vision system. The general implementation of a Kalman filter is showed on figure \ref{fig_gen_kalman}.\clearpage

\begin{figure}[htbp!]
	\centering
	\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
	text width=5em, text centered, rounded corners, minimum height=4em]
	\tikzstyle{line} = [draw, -latex']
	\tikzstyle{sum} = [draw, circle ,fill=red!20, node distance=3cm,
	minimum height=2em]
	\tikzstyle{input} = [coordinate]
	\begin{tikzpicture} [node distance = 2cm, auto]
	\node [input] (ind) {};
	\node [input, right of = ind](guide1){$\sum$};
	\node [block,right of = guide1](sys){System};
	\node [sum,right of = sys](sum1){$\sum$};
	\node [block,below of = sys](kalman){Kalman filter};
	\node [input,above of = sys](dis1){};
	\node [input,above of = sum1](dis2){};
	\node [input,left of = kalman](ud){};
	\node [input,below of = guide1, node distance = 1cm](guide2){};
	
	\path[line] (ind) --node[above]{$u$} (sys);
	\path[line](sys) --node[above]{$x_k$}(sum1);
	\path [line](dis1) --node[right]{$w_d$} (sys);
	\path [line] (dis2) --node[right]{$w_n$} (sum1);
	\path [line](sum1) |- (kalman);
	\path [line](kalman) --node[above]{$\tilde x_{k+1}$} (ud);
	\path [line] (guide1) -- (guide2) -| (kalman);
	
	\end{tikzpicture}
	\caption{General implementation of a Kalman filter}
	\label{fig_gen_kalman}
\end{figure}
\noindent The disturbances are noted $w_d$ and $w_n$ and are determined later, but they are assumed to be Gaussian white noise . The predicted state vector is noted with a tilde, $\tilde x_{k+1}$. The input for the system is denoted $u$. \todo{Der skal skrives noget mere teori her} The Kalman filter gain is found by solving the algebraic Riccati  equation and the filter is implemented as such.
\begin{align}
\tilde x_{k+1} &= F\g\tilde x_k +K_f(y_k-\tilde y_k)\\
\tilde y_{k+1} &= H\g \tilde x_{k+1}
\end{align}
\begin{figure}[htbp!]
	\centering
	\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
	text width=4em, text centered, rounded corners, minimum height=4em]
	\tikzstyle{line} = [draw, -latex']
	\tikzstyle{sum} = [draw, circle ,fill=red!20, node distance=2cm,
	minimum height=2em]
	\tikzstyle{input} = [coordinate]
	\begin{tikzpicture} [node distance = 2cm, auto]
	\node [input](ind){};
	\node[sum,below of = ind](sum1){$\sum$};
	\node [block,below of=sum1](k){$K_f$};
	\node[sum,below of = k](sum2){$\sum$};
	\node[input,right of = sum2](guide1){};
	\node [block,right of = guide1,node distance = 3cm](i){$H$};
	\node [input,right of = i](guide2){};
	\node [block,below of=guide1](f){$F$};
	\node [input,right of = guide1,node distance = 1.5cm](guide3){};
	\node [block,left of= f,node distance = 4cm](i2){$H$};
	
	\path[line] (ind) --node[right]{$y_k$} (sum1);
	\path [line] (sum1) -- (k);
	\path [line] (k) -- (sum2);
	\path [line] (sum2) --node[above]{$x_{k+1}$} (i);
	\path [line] (i) --node[above]{$y_{k+1}$} (guide2);
	\path [line] (f) -|node[above,pos=0.25]{$x_k$} (sum2);
	\path [line] (guide3) |- (f);
	\path [line] (f) --(i2);
	\path [line] (i2) |-(sum1);
	
	
	
	
	\end{tikzpicture}
\end{figure}
\todo[inline]{Dilemmaet sådan som jeg ser det, er hvis kun position vælges som output, så gør kalman filteret det ganske godt, men når hastigheden vælges som output fungerer det slet ikke, og jeg tror det er grundet modellen er for simpel, men spørgsmålet er, om det er nødvendigt at optimere på hastigheds forudsigelsen. Jeg har lige smidt to figurer ind der viser resultatet fra kalman filteret}


\begin{figure}[htbp!]
	\centering
	\begin{tikzpicture}[spy using outlines=
	{circle, magnification=8, connect spies, size=7cm}]
	\begin{axis}[
	width=0.8\textwidth,
	height=0.5\textwidth,
	xlabel=Frame number,
	ylabel=pixels,
	ytick = {0,100,...,800},
	grid=both,
	grid style={line width=.1pt, draw=gray!20},
	]
	\addplot [
	only marks,
	mark size=0.4pt,
	draw=blue,
	] table [x index = 0,y index=1]{./billeder/vision/sim_pos.dat};
	\addlegendentry{$u$-vision}
	\addplot 
	[ 
	only marks,
	mark size=0.6pt,
	color=red,
	] table [x index = 0, y index=2]{./billeder/vision/sim_pos.dat};
	\addlegendentry{$\dot u$-vision}
		\addplot [
	only marks,
	mark size=0.4pt,
	draw=green,
	] table [x index = 0,y index=3]{./billeder/vision/sim_pos.dat};
	\addlegendentry{$u$-kalman}
	\addplot 
	[ 
	only marks,
	mark size=0.6pt,
	color=purple,
	] table [x index = 0, y index=4]{./billeder/vision/sim_pos.dat};
	\addlegendentry{$\dot u$-kalman}
	\coordinate (spypoint) at (axis cs:75,100);
	\coordinate (magnifyglass) at (axis cs:100,400);
	\end{axis}
	\spy [blue, size=3.5cm] on (spypoint)
	in node[fill=white] at (magnifyglass);
	\end{tikzpicture}
	\caption{The calculated velocities in the horizontal- and vertical direction}

\end{figure}
\begin{figure}[htbp!]
	\centering
	\begin{tikzpicture}[spy using outlines=
	{circle, magnification=8, connect spies, size=7cm}]
	\begin{axis}[
	width=0.8\textwidth,
	height=0.5\textwidth,
	xlabel=Frame number,
	ylabel=pixels,
	ytick = {0,100,...,800},
	grid=both,
	grid style={line width=.1pt, draw=gray!20},
	]
	\addplot [
	only marks,
	mark size=0.4pt,
	draw=blue,
	] table [x index = 0,y index=1]{./billeder/vision/sim_vec.dat};
	\addlegendentry{$u$-vision}
	\addplot 
	[ 
	only marks,
	mark size=0.6pt,
	color=red,
	] table [x index = 0, y index=2]{./billeder/vision/sim_vec.dat};
	\addlegendentry{$\dot u$-vision}
	\addplot [
	only marks,
	mark size=0.4pt,
	draw=green,
	] table [x index = 0,y index=3]{./billeder/vision/sim_vec.dat};
	\addlegendentry{$u$-kalman}
	\addplot 
	[ 
	only marks,
	mark size=0.6pt,
	color=yellow,
	] table [x index = 0, y index=4]{./billeder/vision/sim_vec.dat};
	\addlegendentry{$\dot u$-kalman}
	\coordinate (spypoint) at (axis cs:100,50);
	\coordinate (magnifyglass) at (axis cs:75,500);
	\end{axis}
	\spy [blue, size=3.5cm] on (spypoint)
	in node[fill=white] at (magnifyglass);
	\end{tikzpicture}
	\caption{The calculated velocities in the horizontal- and vertical direction}
	
\end{figure}